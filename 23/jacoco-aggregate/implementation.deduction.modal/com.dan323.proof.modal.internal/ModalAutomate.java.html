<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ModalAutomate.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">jacoco-report-aggregate</a> &gt; <a href="../index.html" class="el_bundle">implementation.deduction.modal</a> &gt; <a href="index.source.html" class="el_package">com.dan323.proof.modal.internal</a> &gt; <span class="el_source">ModalAutomate.java</span></div><h1>ModalAutomate.java</h1><pre class="source lang-java linenums">package com.dan323.proof.modal.internal;

import com.dan323.expressions.base.LogicOperation;
import com.dan323.expressions.modal.*;
import com.dan323.expressions.relation.LessEqual;
import com.dan323.expressions.relation.RelationOperation;
import com.dan323.proof.modal.*;
import com.dan323.proof.modal.complex.*;
import com.dan323.proof.modal.proof.ModalNaturalDeduction;
import com.dan323.proof.modal.relational.Reflexive;
import com.dan323.proof.modal.relational.Transitive;

import java.util.*;

/**
 * Class to execute a Natural deduction in modal logic
 *
 * @author daniel
 */
public final class ModalAutomate {

    private ModalNaturalDeduction proof;
    private List&lt;Map.Entry&lt;String, ModalOperation&gt;&gt; goals;
    private List&lt;AbstractModalAction&gt; actionsDone;
    private Map&lt;Integer, Integer&gt; usedForGoal;

    private Map&lt;String, Integer&gt; reflUsed;

    private ModalAutomate() {
    }

<span class="fc" id="L32">    public static final ModalAutomate AUTOMATIC_SOLVER = new ModalAutomate();</span>

    /**
     * Finish the proof if it can be done.
     * It will stop without solving it if it cannot be solved
     *
     * @param naturalDeduction the proof to solve
     */
    public void automate(ModalNaturalDeduction naturalDeduction) {
        // Init state
<span class="fc" id="L42">        proof = naturalDeduction;</span>
<span class="fc" id="L43">        proof.reset();</span>
<span class="fc" id="L44">        goals = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L45">        actionsDone = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L46">        usedForGoal = new HashMap&lt;&gt;();</span>
<span class="fc" id="L47">        reflUsed = new HashMap&lt;&gt;();</span>
<span class="fc" id="L48">        goals.add(new AbstractMap.SimpleEntry&lt;&gt;(proof.getState0(), proof.getGoal()));</span>

<span class="fc" id="L50">        var c = true;</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">        while (c) {</span>
<span class="fc" id="L52">            var goalSize = goals.size();</span>
<span class="fc" id="L53">            var stepsSize = proof.getSteps().size();</span>
<span class="fc" id="L54">            c = applyIntroAndElimRules();</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">            if (c) {</span>
<span class="fc" id="L56">                updateGoal();</span>
                // If the state of the proof has not changed, stop. It has failed
<span class="fc" id="L58">                c = isStateChanged(goalSize, stepsSize);</span>
            }
<span class="fc" id="L60">        }</span>
<span class="fc" id="L61">    }</span>

    /**
     * Checks if the state of the proof has changed according to previous sizes
     *
     * @param previousGoalSize number of goals before the actions
     * @param previousStepSize size of the proof before the actions
     * @return true iff the number of goals of the proof has more steps
     */
    private boolean isStateChanged(int previousGoalSize, int previousStepSize) {
<span class="pc bpc" id="L71" title="1 of 4 branches missed.">        return previousGoalSize != goals.size() || previousStepSize != proof.getSteps().size();</span>
    }

    /**
     * Look for intro rules for the last goal, if none found look and apply eliminate rules
     *
     * @return false iff the proof is finished
     */
    private boolean applyIntroAndElimRules() {
<span class="fc" id="L80">        boolean b = true;</span>
<span class="fc" id="L81">        boolean c = true;</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">        while (b) {</span>
<span class="fc" id="L83">            var intro = introRuleForGoal();</span>
<span class="fc bfc" id="L84" title="All 4 branches covered.">            if (intro.isPresent() || isGoalReached()) {</span>
<span class="fc" id="L85">                updateGoals(intro.orElse(null));</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">                if (goals.isEmpty()) {</span>
<span class="fc" id="L87">                    c = false;</span>
<span class="fc" id="L88">                    b = false;</span>
                }
            } else {
<span class="fc" id="L91">                b = eliminateRules();</span>
            }
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">        return c;</span>
    }

    /**
     * Check if the goal was reabhed
     *
     * @return true if the last goal is equal to the last statement in the proof
     */
    private boolean isGoalReached() {
<span class="fc" id="L103">        var lastGoal = goals.get(goals.size() - 1);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        return !proof.getSteps().isEmpty() &amp;&amp;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">                lastGoal.getValue().equals(proof.getSteps().get(proof.getSteps().size() - 1).getStep())</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">                &amp;&amp; lastGoal.getKey().equals(proof.getSteps().get(proof.getSteps().size() - 1).getState());</span>
    }

    /**
     * Look for an elimination rule, and apply it.
     *
     * @return true iff a rule was found and was applied
     */
    private boolean eliminateRules() {
<span class="fc" id="L115">        return lookForElimRules()</span>
<span class="fc" id="L116">                .map(c -&gt; {</span>
<span class="fc" id="L117">                    c.apply(proof);</span>
<span class="fc" id="L118">                    return true;</span>
<span class="fc" id="L119">                }).orElse(false);</span>
    }

    /**
     * Apply the rule that attains the next goal
     *
     * @param intro action that will attain the goal
     */
    private void updateGoals(AbstractModalAction intro) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (intro != null) {</span>
<span class="fc" id="L129">            intro.apply(proof);</span>
        }
<span class="fc" id="L131">        attainFalseGoal();</span>
<span class="fc" id="L132">        goals.remove(goals.size() - 1);</span>
<span class="fc" id="L133">        usedForGoal.remove(goals.size() + 2);</span>
<span class="fc" id="L134">    }</span>

    /**
     * If the next goal is {@literal False} and the rule NotI is valid,
     * we use it to reach the goal
     */
    private void attainFalseGoal() {
<span class="fc bfc" id="L141" title="All 4 branches covered.">        if (goals.size() &gt; 1 &amp;&amp; goals.get(goals.size() - 1).getValue().equals(ConstantModal.FALSE)) {</span>
<span class="fc" id="L142">            ModalNotI cla = new ModalNotI();</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (cla.isValid(proof)) {</span>
<span class="fc" id="L144">                cla.apply(proof);</span>
<span class="fc" id="L145">                goals.remove(goals.size() - 1);</span>
            }
        }
<span class="fc" id="L148">    }</span>

    /**
     * Check if last goal can be reached with an intro rule
     *
     * @return the action that must be applied to reach the goal
     */
    private Optional&lt;AbstractModalAction&gt; introRuleForGoal() {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (proof.getSteps().isEmpty()) {</span>
<span class="fc" id="L157">            return Optional.empty();</span>
        }
<span class="fc" id="L159">        ModalOperation goal = goals.get(goals.size() - 1).getValue();</span>
<span class="fc" id="L160">        String state = goals.get(goals.size() - 1).getKey();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        for (int i = 0; i &lt; proof.getSteps().size()-1; i++) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (proof.getSteps().get(i).isValid() &amp;&amp;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                    goal.equals(proof.getSteps().get(i).getStep()) &amp;&amp;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                    state.equals(proof.getSteps().get(i).getState())) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                if (!goal.equals(proof.getSteps().get(proof.getSteps().size()-1).getStep()) ||</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">                    !(goal.equals(ConstantModal.FALSE) ||</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                            state.equals(proof.getSteps().get(proof.getSteps().size()-1).getState()))) {</span>
<span class="fc" id="L168">                    return Optional.of(new ModalCopy(i + 1));</span>
                }
            }
        }
<span class="fc" id="L172">        Optional&lt;AbstractModalAction&gt; sol = Optional.empty();</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (goal instanceof ConjunctionModal conj) {</span>
<span class="fc" id="L174">            sol = introRuleForGoalConjuntion(conj, state);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        } else if (goal instanceof ImplicationModal imp) {</span>
<span class="fc" id="L176">            sol = introRuleForGoalImplication(imp, state);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        } else if (goal instanceof DisjunctionModal disj) {</span>
<span class="fc" id="L178">            sol = introRuleForGoalDisjunction(disj, state);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        } else if (goal instanceof NegationModal neg) {</span>
<span class="fc" id="L180">            sol = introRuleForGoalNegation(neg, state);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        } else if (goal.equals(ConstantModal.FALSE)) {</span>
<span class="fc" id="L182">            sol = introRuleForGoalContradiction();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        } else if (goal instanceof Always always) {</span>
<span class="fc" id="L184">            sol = introRuleForGoalAlways(always, state);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        } else if (goal instanceof Sometime sometime) {</span>
<span class="fc" id="L186">            sol = introRuleForGoalSometime(sometime, state);</span>
        }
<span class="fc" id="L188">        return sol;</span>
    }

    private Optional&lt;AbstractModalAction&gt; introRuleForGoalSometime(Sometime sometime, String state) {
<span class="fc" id="L192">        ModalLogicalOperation element = sometime.getElement();</span>
<span class="fc" id="L193">        Map&lt;String, Integer&gt; states = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        for (int k = 0; k &lt; proof.getSteps().size(); k++) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (proof.getSteps().get(k).isValid()) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                if (proof.getSteps().get(k).getStep().equals(element)) {</span>
<span class="fc" id="L197">                    states.put(proof.getSteps().get(k).getState(), k+1);</span>
                }
            }
        }
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for (int k = 0; k &lt; proof.getSteps().size(); k++) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            if (proof.getSteps().get(k).isValid()) {</span>
<span class="pc bpc" id="L203" title="1 of 4 branches missed.">                if (proof.getSteps().get(k).getStep() instanceof LessEqual lessEqual &amp;&amp; lessEqual.getLeft().equals(state)) {</span>
<span class="fc" id="L204">                    Integer finalState = states.get(lessEqual.getRight());</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                    if (finalState != null) {</span>
<span class="fc" id="L206">                        return Optional.of(new ModalDiaI(finalState, k+1));</span>
                    }
                }
            }
        }
<span class="fc" id="L211">        return Optional.empty();</span>
    }

    private Optional&lt;AbstractModalAction&gt; introRuleForGoalAlways(Always goal, String state) {
<span class="fc" id="L215">        ModalLogicalOperation element = goal.getElement();</span>
<span class="fc" id="L216">        int i = 0;</span>
<span class="fc" id="L217">        int assmsLevel = proof.getSteps().get(proof.getSteps().size() - 1).getAssumptionLevel();</span>
<span class="fc bfc" id="L218" title="All 4 branches covered.">        while (proof.getSteps().size() - 1 - i &gt;= 0 &amp;&amp; proof.getSteps().get(proof.getSteps().size() - 1 - i).getAssumptionLevel() &gt;= assmsLevel) {</span>
<span class="fc" id="L219">            i++;</span>
        }
<span class="fc bfc" id="L221" title="All 4 branches covered.">        if (proof.getSteps().get(proof.getSteps().size() - i).getStep() instanceof LessEqual lessEqual &amp;&amp; lessEqual.getLeft().equals(state)) {</span>
<span class="fc" id="L222">            var finalState = lessEqual.getRight();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            for (int k = 0; k &lt; proof.getSteps().size(); k++) {</span>
<span class="fc bfc" id="L224" title="All 6 branches covered.">                if (proof.getSteps().get(k).isValid() &amp;&amp; proof.getSteps().get(k).getStep().equals(element) &amp;&amp; proof.getSteps().get(k).getState().equals(finalState)) {</span>
<span class="pc bpc" id="L225" title="3 of 4 branches missed.">                    if (k + 1 &lt; proof.getSteps().size() &amp;&amp; !proof.getSteps().get(proof.getSteps().size() - 1).getStep().equals(proof.getSteps().get(k).getStep())) {</span>
<span class="nc" id="L226">                        (new ModalCopy(k + 1)).apply(proof);</span>
                    }
<span class="fc" id="L228">                    return Optional.of(new ModalBoxI());</span>
                }
            }
        }
<span class="fc" id="L232">        return Optional.empty();</span>
    }

    /**
     * Check if last goal can be reached with an intro rule in case it is {@link ConstantModal#FALSE}
     *
     * @return the action {@link ModalFI} that must be used, if possible
     */
    private Optional&lt;AbstractModalAction&gt; introRuleForGoalContradiction() {
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (int i = 0; i &lt; proof.getSteps().size(); i++) {</span>
<span class="fc bfc" id="L242" title="All 4 branches covered.">            if (proof.getSteps().get(i).isValid() &amp;&amp; proof.getSteps().get(i).getStep() instanceof NegationModal neg) {</span>
<span class="fc" id="L243">                ModalLogicalOperation element = neg.getElement();</span>
<span class="fc" id="L244">                var state = proof.getSteps().get(i).getState();</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                for (int j = 0; j &lt; proof.getSteps().size(); j++) {</span>
<span class="fc bfc" id="L246" title="All 6 branches covered.">                    if (proof.getSteps().get(j).isValid() &amp;&amp; proof.getSteps().get(j).getStep().equals(element) &amp;&amp; proof.getSteps().get(j).getState().equals(state)) {</span>
<span class="fc" id="L247">                        return Optional.of(new ModalFI(j + 1, i + 1));</span>
                    }
                }
            }
        }
<span class="fc" id="L252">        return Optional.empty();</span>
    }

    /**
     * Check if last goal can be reached with an intro rule in case it is {@link NegationModal}
     *
     * @return the action {@link ModalNotI} that must be used, if possible
     */
    private Optional&lt;AbstractModalAction&gt; introRuleForGoalNegation(NegationModal goal, String state) {
<span class="fc" id="L261">        ModalOperation element = goal.getElement();</span>
<span class="fc" id="L262">        int i = 0;</span>
<span class="fc" id="L263">        int assmsLevel = proof.getSteps().get(proof.getSteps().size() - 1).getAssumptionLevel();</span>
<span class="fc bfc" id="L264" title="All 4 branches covered.">        while (proof.getSteps().size() - 1 - i &gt;= 0 &amp;&amp; proof.getSteps().get(proof.getSteps().size() - 1 - i).getAssumptionLevel() &gt;= assmsLevel) {</span>
<span class="fc" id="L265">            i++;</span>
        }
<span class="pc bpc" id="L267" title="3 of 4 branches missed.">        if (proof.getSteps().get(proof.getSteps().size() - i).getStep().equals(element) &amp;&amp; proof.getSteps().get(proof.getSteps().size() - i).getState().equals(state)) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            for (int k = 0; k &lt; proof.getSteps().size(); k++) {</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">                if (proof.getSteps().get(k).isValid() &amp;&amp; proof.getSteps().get(k).getStep().equals(ConstantModal.FALSE)) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                    if (k + 1 &lt; proof.getSteps().size()) {</span>
<span class="nc" id="L271">                        (new ModalCopy(k + 1)).apply(proof);</span>
                    }
<span class="nc" id="L273">                    return Optional.of(new ModalNotI());</span>
                }
            }
        }
<span class="fc" id="L277">        return Optional.empty();</span>
    }

    /**
     * Check if last goal can be reached with an intro rule in case it is {@link DisjunctionModal}
     *
     * @return the action {@link ModalOrI1} or {@link ModalOrI2} that must be used, if possible
     */
    private Optional&lt;AbstractModalAction&gt; introRuleForGoalDisjunction(DisjunctionModal goal, String state) {
<span class="fc" id="L286">        ModalLogicalOperation left = goal.getLeft();</span>
<span class="fc" id="L287">        ModalLogicalOperation right = goal.getRight();</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (int k = 0; k &lt; proof.getSteps().size(); k++) {</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (proof.getSteps().get(k).isValid()) {</span>
<span class="pc bpc" id="L290" title="3 of 4 branches missed.">                if (proof.getSteps().get(k).getStep().equals(left) &amp;&amp; proof.getSteps().get(k).getState().equals(state)) {</span>
<span class="nc" id="L291">                    return Optional.of(new ModalOrI1(k + 1, right));</span>
                }
<span class="pc bpc" id="L293" title="3 of 4 branches missed.">                if (proof.getSteps().get(k).getStep().equals(right) &amp;&amp; proof.getSteps().get(k).getState().equals(state)) {</span>
<span class="nc" id="L294">                    return Optional.of(new ModalOrI2(k + 1, left));</span>
                }
            }
        }
<span class="fc" id="L298">        return Optional.empty();</span>
    }

    /**
     * Check if last goal can be reached with an intro rule in case it is {@link ConjunctionModal}
     *
     * @return the action {@link ModalAndI} that must be used, if possible
     */
    private Optional&lt;AbstractModalAction&gt; introRuleForGoalConjuntion(ConjunctionModal goal, String state) {
<span class="fc" id="L307">        ModalLogicalOperation left = goal.getLeft();</span>
<span class="fc" id="L308">        int a = 0;</span>
<span class="fc" id="L309">        ModalLogicalOperation right = goal.getRight();</span>
<span class="fc" id="L310">        int b = 0;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (int i = 0; i &lt; proof.getSteps().size(); i++) {</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (proof.getSteps().get(i).isValid()) {</span>
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">                if (left.equals(proof.getSteps().get(i).getStep()) &amp;&amp; state.equals(proof.getSteps().get(i).getState())) {</span>
<span class="fc" id="L314">                    a = i + 1;</span>
                }
<span class="pc bpc" id="L316" title="1 of 4 branches missed.">                if (right.equals(proof.getSteps().get(i).getStep()) &amp;&amp; state.equals(proof.getSteps().get(i).getState())) {</span>
<span class="fc" id="L317">                    b = i + 1;</span>
                }
            }
<span class="pc bpc" id="L320" title="1 of 4 branches missed.">            if (a &gt; 0 &amp;&amp; b &gt; 0) {</span>
<span class="fc" id="L321">                return Optional.of(new ModalAndI(a, b));</span>
            }
        }
<span class="fc" id="L324">        return Optional.empty();</span>
    }

    /**
     * Check if last goal can be reached with an intro rule in case it is {@link ImplicationModal}
     *
     * @return the action {@link ModalDeductionTheorem} that must be used, if possible
     */
    private Optional&lt;AbstractModalAction&gt; introRuleForGoalImplication(ImplicationModal goal, String state) {
<span class="fc" id="L333">        ModalLogicalOperation left = (goal).getLeft();</span>
<span class="fc" id="L334">        ModalLogicalOperation right = (goal).getRight();</span>
<span class="fc" id="L335">        int i = 0;</span>
<span class="fc" id="L336">        int assmsLevel = proof.getSteps().get(proof.getSteps().size() - 1).getAssumptionLevel();</span>
<span class="fc bfc" id="L337" title="All 4 branches covered.">        while (proof.getSteps().size() - 1 - i &gt;= 0 &amp;&amp; proof.getSteps().get(proof.getSteps().size() - 1 - i).getAssumptionLevel() &gt;= assmsLevel) {</span>
<span class="fc" id="L338">            i++;</span>
        }
<span class="pc bpc" id="L340" title="1 of 4 branches missed.">        if (proof.getSteps().get(proof.getSteps().size() - i).getStep().equals(left) &amp;&amp; proof.getSteps().get(proof.getSteps().size() - i).getState().equals(state)) {</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">            for (int k = 0; k &lt; proof.getSteps().size(); k++) {</span>
<span class="pc bpc" id="L342" title="1 of 6 branches missed.">                if (proof.getSteps().get(k).isValid() &amp;&amp; proof.getSteps().get(k).getStep().equals(right) &amp;&amp; proof.getSteps().get(k).getState().equals(state)) {</span>
<span class="pc bpc" id="L343" title="1 of 4 branches missed.">                    if (k + 1 &lt; proof.getSteps().size() &amp;&amp; !proof.getSteps().get(proof.getSteps().size() - 1).getStep().equals(proof.getSteps().get(k).getStep())) {</span>
<span class="nc" id="L344">                        (new ModalCopy(k + 1)).apply(proof);</span>
                    }
<span class="fc" id="L346">                    return Optional.of(new ModalDeductionTheorem());</span>
                }
            }
        }
<span class="fc" id="L350">        return Optional.empty();</span>
    }

    private Optional&lt;AbstractModalAction&gt; lookForElimRules() {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (int i = 0; i &lt; proof.getSteps().size(); i++) {</span>
<span class="fc bfc" id="L355" title="All 4 branches covered.">            if (proof.getSteps().get(i).isValid() &amp;&amp; proof.getSteps().get(i).getStep() instanceof ModalLogicalOperation) {</span>
<span class="fc" id="L356">                int k = i + 1;</span>
<span class="fc" id="L357">                var act = Optional.of(new ModalDeMorgan(k))</span>
<span class="fc" id="L358">                        .flatMap(this::checkSingleAction)</span>
<span class="fc" id="L359">                        .or(() -&gt; Optional.of(new DeMorgan(k))</span>
<span class="fc" id="L360">                                .flatMap(this::checkSingleAction))</span>
<span class="fc" id="L361">                        .or(() -&gt; Optional.of(new ModalNotE(k))</span>
<span class="fc" id="L362">                                .flatMap(this::checkSingleAction))</span>
<span class="fc" id="L363">                        .or(() -&gt; Optional.of(new Reflexive(k))</span>
<span class="fc" id="L364">                                .flatMap(this::checkReflAction))</span>
<span class="fc" id="L365">                        .or(() -&gt; checkAdditionOfAndI(k - 1))</span>
<span class="fc" id="L366">                        .or(() -&gt; checkAdditionOfDisjIModPonens(k - 1))</span>
<span class="fc" id="L367">                        .or(() -&gt; checkAdditionOfAlways(k - 1))</span>
<span class="fc" id="L368">                        .or(() -&gt; checkAdditionOfContraAlw(k - 1));</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">                if (act.isPresent()) {</span>
<span class="fc" id="L370">                    return act;</span>
                }
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">            } else if (proof.getSteps().get(i).isValid() &amp;&amp; proof.getSteps().get(i).getStep() instanceof RelationOperation){</span>
<span class="fc" id="L373">                var act = checkAdditionOfTrans(i);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (act.isPresent()){</span>
<span class="fc" id="L375">                    return act;</span>
                }
            }
        }
<span class="fc" id="L379">        return Optional.empty();</span>
    }

    private Optional&lt;AbstractModalAction&gt; checkAdditionOfContraAlw(int i) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        for (int j = 0; j &lt; proof.getSteps().size(); j++) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (proof.getSteps().get(j).isValid()) {</span>
<span class="fc" id="L385">                var opt = Optional.of(new ContraSometime(i + 1, j + 1))</span>
<span class="fc" id="L386">                        .flatMap(this::checkSingleAction);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                if (opt.isPresent()) {</span>
<span class="fc" id="L388">                    return opt;</span>
                }
            }
        }
<span class="fc" id="L392">        return Optional.empty();</span>
    }

    private Optional&lt;AbstractModalAction&gt; checkAdditionOfTrans(int i) {
<span class="pc bpc" id="L396" title="1 of 4 branches missed.">        if (proof.getSteps().get(i).getStep() instanceof LessEqual lessEqual &amp;&amp; !lessEqual.getLeft().equals(lessEqual.getRight())) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            for (int j = 0; j &lt; proof.getSteps().size(); j++) {</span>
<span class="fc bfc" id="L398" title="All 6 branches covered.">                if (proof.getSteps().get(j).isValid() &amp;&amp; proof.getSteps().get(j).getStep() instanceof LessEqual lessEqual1 &amp;&amp; !lessEqual1.getLeft().equals(lessEqual1.getRight())) {</span>
<span class="fc" id="L399">                    var opt = Optional.of(new Transitive(i + 1, j + 1))</span>
<span class="fc" id="L400">                            .flatMap(this::checkSingleAction);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                    if (opt.isPresent()) {</span>
<span class="fc" id="L402">                        return opt;</span>
                    }
                }
            }
        }
<span class="fc" id="L407">        return Optional.empty();</span>
    }

    private Optional&lt;AbstractModalAction&gt; checkAdditionOfAlways(int i) {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (int j = 0; j &lt; proof.getSteps().size(); j++) {</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            if (proof.getSteps().get(j).isValid()) {</span>
<span class="fc" id="L413">                var opt = Optional.of(new ModalBoxE(i + 1, j + 1))</span>
<span class="fc" id="L414">                        .flatMap(this::checkSingleAction);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                if (opt.isPresent()) {</span>
<span class="fc" id="L416">                    return opt;</span>
                }
            }
        }
<span class="fc" id="L420">        return Optional.empty();</span>
    }

    private Optional&lt;AbstractModalAction&gt; checkAdditionOfAndI(int i) {
<span class="fc" id="L424">        return Optional.of(new ModalAndE1(i + 1))</span>
<span class="fc" id="L425">                .flatMap(this::checkSingleAction)</span>
<span class="fc" id="L426">                .or(() -&gt; Optional.of(new ModalAndE2(i + 1))</span>
<span class="fc" id="L427">                        .flatMap(this::checkSingleAction));</span>
    }

    /**
     * Check that the action has not already done and it is valid
     *
     * @param act action to be checked for validity
     * @return the action if it valid
     */
    private Optional&lt;AbstractModalAction&gt; checkSingleAction(AbstractModalAction act) {
<span class="fc" id="L437">        var answer = Optional.ofNullable(act)</span>
<span class="fc bfc" id="L438" title="All 4 branches covered.">                .filter(a -&gt; !actionsDone.contains(a) &amp;&amp; a.isValid(proof));</span>
<span class="fc" id="L439">        answer.ifPresent(a -&gt; actionsDone.add(a));</span>
<span class="fc" id="L440">        return answer;</span>
    }

    private Optional&lt;AbstractModalAction&gt; checkReflAction(Reflexive act) {
<span class="fc" id="L444">        int k = act.getStep();</span>
<span class="fc" id="L445">        var state = proof.getSteps().get(k - 1).getState();</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (reflUsed.containsKey(state)) {</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">            if (!proof.getSteps().get(reflUsed.get(state)).isValid()) {</span>
<span class="nc" id="L448">                reflUsed.put(state, k);</span>
<span class="nc" id="L449">                return Optional.of(act);</span>
            }
        } else {
<span class="fc" id="L452">            reflUsed.put(state, k);</span>
<span class="fc" id="L453">            return Optional.of(act);</span>
        }
<span class="fc" id="L455">        return Optional.empty();</span>
    }

    private Optional&lt;AbstractModalAction&gt; checkAdditionOfDisjIModPonens(int i) {
<span class="fc bfc" id="L459" title="All 2 branches covered.">        for (int j = 0; j &lt; proof.getSteps().size(); j++) {</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">            if (proof.getSteps().get(j).isValid()) {</span>
<span class="fc" id="L461">                int k = j + 1;</span>
<span class="fc" id="L462">                var act = Optional.of(new ModalModusPonens(i + 1, k))</span>
<span class="fc" id="L463">                        .flatMap(this::checkSingleAction)</span>
<span class="fc" id="L464">                        .or(() -&gt; Optional.of(new ModalOrE1(i + 1, k))</span>
<span class="fc" id="L465">                                .flatMap(this::checkSingleAction))</span>
<span class="fc" id="L466">                        .or(() -&gt; Optional.of(new ModalOrE2(i + 1, k))</span>
<span class="fc" id="L467">                                .flatMap(this::checkSingleAction));</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                if (act.isPresent()) {</span>
<span class="fc" id="L469">                    return act;</span>
                }
            }
        }
<span class="fc" id="L473">        return Optional.empty();</span>
    }

    /**
     * Add a new goal to make easier to reach the current goal, if possible
     */
    private void updateGoal() {
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (goals.get(goals.size() - 1).getValue().equals(ConstantModal.FALSE)) {</span>
<span class="fc" id="L481">            lastGoalFalse();</span>
        } else {
<span class="fc" id="L483">            var state = goals.get(goals.size() - 1).getKey();</span>
<span class="fc" id="L484">            ModalLogicalOperation goal = (ModalLogicalOperation) goals.get(goals.size() - 1).getValue();</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (goal instanceof ConjunctionModal conj) {</span>
<span class="fc" id="L486">                updateGoalConjunction(conj, state);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">            } else if (goal instanceof ImplicationModal imp) {</span>
<span class="fc" id="L488">                updateGoalImplication(imp, state);</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">            } else if (goal instanceof NegationModal neg) {</span>
<span class="fc" id="L490">                updateGoalNegation(neg, state);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            } else if (goal instanceof Always always) {</span>
<span class="fc" id="L492">                updateGoalAlways(always, state);</span>
            } else {
<span class="fc" id="L494">                updateGoalContradiction(goal, state);</span>
            }
        }
<span class="fc" id="L497">    }</span>

    /**
     * Update the goal list in case the last goal is {@link ConstantModal#FALSE}
     */
    private void lastGoalFalse() {
<span class="fc" id="L503">        int j = -1;</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">        for (int i = 0; i &lt; proof.getSteps().size(); i++) {</span>
<span class="fc" id="L505">            boolean b = true;</span>
<span class="pc bpc" id="L506" title="2 of 4 branches missed.">            if (!usedForGoal.containsValue(i) &amp;&amp; proof.getSteps().get(i).isValid()) {</span>
<span class="fc" id="L507">                String state = proof.getSteps().get(i).getState();</span>
<span class="fc" id="L508">                LogicOperation log = proof.getSteps().get(i).getStep();</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                if (log instanceof NegationModal neg) {</span>
<span class="fc" id="L510">                    goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, neg.getElement()));</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">                } else if (log instanceof DisjunctionModal disj) {</span>
<span class="fc" id="L512">                    goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, new NegationModal(disj.getLeft())));</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">                } else if (log instanceof ImplicationModal imp) {</span>
<span class="nc" id="L514">                    goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, imp.getLeft()));</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                } else if (log instanceof Sometime some){</span>
<span class="fc" id="L516">                    goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, new Always(new NegationModal(some.getElement())) ));</span>
                }else {
<span class="fc" id="L518">                    b = false;</span>
                }
<span class="fc bfc" id="L520" title="All 2 branches covered.">                if (b) {</span>
<span class="fc" id="L521">                    j = i;</span>
<span class="fc" id="L522">                    break;</span>
                }
            }
        }
<span class="fc" id="L526">        usedForGoal.put(goals.size(), j);</span>
<span class="fc" id="L527">    }</span>

    /**
     * Create new goal a assumption from the last goal. Assume the opposite
     * and try to reach a contradiction
     *
     * @param goal last goal
     */
    private void updateGoalContradiction(ModalLogicalOperation goal, String state) {
<span class="fc" id="L536">        var neg = new NegationModal(goal);</span>
<span class="fc" id="L537">        boolean alreadyExists = false;</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        for (int i = 0; i &lt; proof.getSteps().size(); i++) {</span>
<span class="pc bpc" id="L539" title="1 of 4 branches missed.">            if (proof.getSteps().get(i).isValid() &amp;&amp; proof.getSteps().get(i).getStep().equals(neg)) {</span>
<span class="fc" id="L540">                alreadyExists = true;</span>
<span class="fc" id="L541">                break;</span>
            }
        }
<span class="fc bfc" id="L544" title="All 2 branches covered.">        if (!alreadyExists) {</span>
<span class="fc" id="L545">            goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, new NegationModal(new NegationModal(goal))));</span>
<span class="fc" id="L546">            goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, ConstantModal.FALSE));</span>
<span class="fc" id="L547">            (new ModalAssume(neg, state)).apply(proof);</span>
        }
<span class="fc" id="L549">    }</span>

    /**
     * Create new goal and assumption from the last goal of type -
     *
     * @param goal last goal of type -
     */
    private void updateGoalNegation(NegationModal goal, String state) {
<span class="fc" id="L557">        goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, ConstantModal.FALSE));</span>
<span class="fc" id="L558">        (new ModalAssume(goal.getElement(), state)).apply(proof);</span>
<span class="fc" id="L559">    }</span>

    /**
     * Create new goal and assumption from the last goal of type -&gt;
     *
     * @param goal last goal of type -&gt;
     */
    private void updateGoalImplication(ImplicationModal goal, String state) {
<span class="fc" id="L567">        goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, goal.getRight()));</span>
<span class="fc" id="L568">        (new ModalAssume(goal.getLeft(), state)).apply(proof);</span>
<span class="fc" id="L569">    }</span>

    /**
     * Create new goals from the last goal of type AND
     *
     * @param goal last goal of type AND
     */
    private void updateGoalConjunction(ConjunctionModal goal, String state) {
<span class="fc" id="L577">        goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, goal.getLeft()));</span>
<span class="fc" id="L578">        goals.add(new AbstractMap.SimpleEntry&lt;&gt;(state, goal.getRight()));</span>
<span class="fc" id="L579">    }</span>

    /**
     * Create new goals from the last goal of type []
     *
     * @param goal last goal of type []
     */
    private void updateGoalAlways(Always goal, String state) {
<span class="fc" id="L587">        var newState = proof.newState();</span>
<span class="fc" id="L588">        goals.add(new AbstractMap.SimpleEntry&lt;&gt;(newState, goal.getElement()));</span>
<span class="fc" id="L589">        (new ModalAssume(new LessEqual(state, newState))).apply(proof);</span>
<span class="fc" id="L590">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>